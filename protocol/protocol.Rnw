\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}

\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{comment}
\usepackage{hyperref}
\usepackage{cite}
%page boarders
\usepackage[vmargin=3cm, hmargin=3cm]{geometry}
\usepackage{float}
\floatstyle{plaintop}
\usepackage{paralist} %compactitem
\usepackage{fixltx2e} %some latex fixes
\usepackage{microtype} %Subliminal refinements towards typographical perfection
\setlength{\emergencystretch}{2em}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathrsfs} %Support use of the Raph Smithâ€™s Formal Script font in mathematics
\usepackage[sc]{mathpazo} %mathematical fonts
\usepackage{amsfonts}
\usepackage{booktabs}
\usepackage[margin=10pt, font=small, labelfont=bf]{caption}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{color}
\floatstyle{plaintop}
\usepackage{float}
\restylefloat{table}
\usepackage {tikz}
\usetikzlibrary{positioning}
\usepackage{pgfplots}

% a nice not implies
\newcommand{\notimplies}{%
  \mathrel{{\ooalign{\hidewidth$\not\phantom{=}$\hidewidth\cr$\implies$}}}}
  
% todos  
\newcommand\todo[1]{\textcolor{red}{TODO: #1}}

% number equations s.t. they can be referenced easily
\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}
% within an align* environment, number and label the equation. #1 is the label text to be appended to eqn:
\newcommand\neqn[1]{\numberthis\label{eq:#1}}

% theorem, lemma, ...
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{theorem}{Theorem}
\newtheorem{assumption}{Assumption}
\newtheorem{definition}{Definition}

% math stuff
% vectors
\newcommand{\vect}[1]{\vec{#1}}

% total order relation
\newcommand{\tor}{\ensuremath{\leq_R}}
\newcommand{\osum}{\ensuremath{\leq_{\text{sum}}}}
\newcommand{\olex}{\ensuremath{\leq_{\text{lex}}}}

% sets
\newcommand{\sC}{\ensuremath{S_{\text{c}}}}
\newcommand{\sA}{\ensuremath{S_{\text{a}}}}
\newcommand{\sR}{\ensuremath{S_{\text{r}}}}

% concatenation of paths
\newcommand{\cP}[2]{\ensuremath{#1;#2}}

% style of listings
\definecolor{Gray}{gray}{0.5}
\definecolor{OliveGreen}{cmyk}{0.64,0,0.95,0.40}
\lstset{
    language=C++,
    basicstyle=\ttfamily,
    keywordstyle=\color{blue},
    commentstyle=\color{OliveGreen},
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    showspaces=false,
    showtabs=false,
    numbers=left,
    frame=lrtb,
}

% 
\title{A multi-criteria priority queue for the Pheet task scheduling framework\\
\normalsize Technical report for \\``Project in Software Engineering \& Internet Computing''
}
\author{Martin Kalany, 0825673\\
Vienna University of Technology}

\begin{document}
\maketitle

%scale factor for graphs
\setkeys{Gin}{width=0.5\textwidth}

%R functions for plot generation
<<echo=FALSE, include=FALSE>>=
\SweaveInput{functions.Rnw}
@

%\pagebreak	

\begin{abstract}
\cite{Wimmer14} \todo{abstract}
\end{abstract}

\pagebreak
\tableofcontents
\pagebreak

\section{Introduction} \label{sec:intro}
% explain the idea of this work in a couple of sentences. This is for the informed reader.

% Introduce pheet
Pheet\footnote{\url{www.pheet.org}} is an open-source task scheduling framework for shared memory systems   
and is based on the task-parallel programming model, which allows a programmer to explicitly expose the parallelism of an application.
% The build-up for task priorities
Runtime systems based on the task-parallel model typically impose a non-adaptive, application independent execution order on the tasks where the scheduler is unaware of the preferred execution order of the tasks (The tasks are processed in, e.g., LIFO-order).
% The problem with Dijkstra's algorithm
While it has proven to be an efficient strategy for parallelization \todo{citation needed}, this approach has not been particularly useful for the parallelization of algorithms relying on priority queues (such as Dijkstra's famous algorithm for the single-source shortest path problem (SSSP) \cite{Dijkstra59}), since two work pools have to be maintained: 
One is used by the scheduling framework to maintain tasks that are yet to be executed; the other is required by the algorithm itself to determine the execution order of the tasks.

% Priority task scheduling
\emph{Priority task scheduling}, introduced by Wimmer et al.~\cite{WVTCT13}, addresses this problem by making the preferred execution order of tasks known to the scheduler. 
To achieve this, the task scheduler utilizes a concurrent priority queue which fulfills the ordering requirements imposed by the algorithm by assigning discrete priority values to the tasks.
Wimmer \cite{Wimmer14} further states that a scheduler based on the task priority scheduling model allows for an efficient parallel implementation of any algorithm relying on priority queues is possible.
They back up their claim by providing a parallel implementation of Dijkstra's algorithm on top of Pheet, which utilizes a scheduler based on the priority task scheduling model.

% Pareto priorities
In their dissertation \cite{Wimmer14}, they suggest to generalize the idea of priority task scheduling to multi-dimensional (or \emph{Pareto-}) priorities, which would allow for an efficient parallel implementation of e.g., algorithms solving the multi-criteria shortest path problem (MSP)\footnote{Sometimes also called multi-objective shortest path problem, multi-objective optimization or multi-objective search.} as discussed in \cite{Martins84}.
They outline a different advantage of using multi-dimensional priorities for task scheduling, which is independent of the algorithm that utilizes the scheduler:
Multi-dimensional priorities establish only a partial ordering on the tasks, which gives the scheduler more flexibility in terms of which task to execute next. 

% Our work
In this work, we investigate a potential implementation of such a multi-dimensional priority queue for the Pheet task scheduling framework, which is then used in turn for a parallel algorithm solving the MSP. 
% MSP is not our focus
We note here that the goal of our work is not to provide a better algorithm for the MSP; we investigate the potential of a multi-dimensional priority-aware task scheduler and use the MSP only as an example application.
% Performance evaluation
We make a comparison based performance evaluation by comparing the execution time of the MSP-algorithm employing different scheduler implementations: 

\todo{lsm/klsm/strategy: linear combination; vs.\ pareto-queue}


\subsubsection*{Outline} \label{sec:intro:outline}
We give a formal definition of the multi-criteria shortest path problem in Section \ref{sec:shortest_path}, where we also discusses the hardness of the problem.
In Section \ref{sec:pheet}, we provide a general introduction to the Pheet task scheduling framework and a more detailed presentation of the concepts used in Pheet that are relevant for this work.

\todo{...}
\section{Pheet} \label{sec:pheet}
% what we will do in this section
In this section, we provide a general introduction to Pheet-related and -specific concepts that are relevant for this technical report. 

% reference Martin's dissertation
A detailed introduction to Pheet, the concepts it is built on and the research based on it can be found in the dissertation of Martin Wimmer \cite{Wimmer14}. 

\subsubsection*{Philosophy} \label{sec:pheet:philosophy}
% How is pheet implemented, what are its goals?
Pheet is a task-parallel programming library with the goal of providing a simple-to-use framework for the quick parallelization of algorithms.
Its flexible plug-in architecture based on C++ template meta-programming allows for any component in the task scheduling system to be replaced by an alternative implementation.
Additionally, Pheet provides a set of micro-benchmarks (that aim to evaluate specific aspects of the scheduling framework) and fine grained performance counters (that provide detailed insight into the scheduler and supporting data structures), which makes the framework a suitable platform for the implementation and testing of new components such as schedulers or priority queues. 

\subsection{Concepts} \label{sec:pheet:concepts}

\subsubsection{Places} \label{sec:pheet:places}
A \emph{place}\cite{Wimmer14} denotes a single worker thread in the Pheet scheduling system that is pinned to specific processor, that is, a place will not migrate to another processing unit during execution.
Each processor utilized by Pheet is assigned exactly one place, implying a one-to-one correspondence of places and processors. 
By uniquely identifying processors, places simplify the implementation of parellel algorithms and data structures.

Furthermore, places are employed to deal with aspects related to the memory hierarchy as well as locality. 
However, as those concepts are not considered in our contribution, we refer the interested reader to the work of Wimmer\cite{Wimmer14}.


\subsubsection{Task parallelism} \label{sec:pheet:task_parallel}
% work pool
Pheet is based on the \emph{task-parallel model}, where a task is a small portion of work that is to be executed sequentially.
As soon as a processor is ready to execute work, it retrieves a task from the \emph{work pool}, which contains all the tasks that have yet to be executed.
A task may itself create additional tasks that are then stored in the work pool.

A famous algorithm based on the work pool pattern is Dijkstra's algorithm \cite{Dijkstra59} for the shortest path problem:
The algorithm requires a priority queue (that may be implemented as e.g., a simple binary search tree or a Fibonacci heap), which is but a work pool.

% task parallelism
Additionally, the programmer may define dependencies between the tasks which ensure that a task is not executed before all required prerequisites are met; if, however, two tasks do not depend on each other, they may be executed in parallel (or sequentially in arbitrary order).

Note that in a task parallel program, the work pool is not necessarily a centralized data structure; each place may maintain its own. 
Furthermore, once place starts executing a task, the task will stay at this place until its execution is finished. 

\subsection{Task priorities}  \label{sec:pheet:task_priorites}

\subsubsection{Strategy scheduling} \label{sec:pheet:scheduling}
% What does the scheduler do?
The task parallel model is independent of any machine specifics. 
It merely exposes the available work to the \emph{scheduler}, which is responsible for devising a schedule, i.e., a mapping of tasks to the processors such that the partial order of the tasks is maintained, thereby determining which processor executes a task as well as the execution order of the tasks. 

\subsubsection{Dead tasks} \label{sec:pheet:dead_tasks}

\begin{comment}
% Online/offline scheduling; what is used in Pheet and why
The schedulers developed for Pheet employ \emph{online scheduling}, where -- in contrast to \emph{offline scheduling} -- the schedule cannot be precomputed statically, since not all the required information is available before the execution.
This is due to e.g., new tasks being created during the execution and/or the nondeterministic execution time of tasks.

% Explain that we don't explain scheduling
Task scheduling itself is a vast and active area of research with many different variations in the problem setting and models.
Since we do not deal with any complex scheduling in this work, we refrain from giving a more elaborate introduction and refer the reader to the Wimmer's dissertation\cite{Wimmer14}, which contains several pointers to the literature.
\end{comment}



% Main part of the work
\section{Multi-criteria priority queue} \label{sec:mcpq}
\todo{Description and analysis of: virtual array, log-structured list, put/pop, top, steal,\dots}

\section{Bits and pieces}
%Node
\todo{do we really need this? or can we assume that it is known/intuitively understandable?}
\begin{comment}
\begin{minipage}[c]{\linewidth}
\begin{lstlisting}[label=lst:Node, caption=Basic structure and operations of Node.]
class Node {
  /* All nodes adjacent to an outgoing arc of this Node. */
  Set<Node> neighbors();
}
\end{lstlisting}
\end{minipage}

% Path
\begin{minipage}[c]{\linewidth}
\begin{lstlisting}[label=lst:Path, caption=Basic structure and operations of Path.]
class Path {
  Path step(Arc a);
  Node tail();
  Node head();
  Weight_Vector weight();
  bool dominated;
}
\end{lstlisting}
\end{minipage}
\end{comment}
% pareto priority queue idea
%\begin{comment}
A Pareto priority queue ensures that that the next task to be executed is a Pareto optimum, i.e., a task for which the partial solution is not dominated by the partial solution of any other task \cite{Wimmer14}


\section{Shortest path problems} \label{sec:shortest_path}
% Informally introduce shortest path
The problem of finding a shortest path between two nodes in a graph is a classical problem in computer science with numerous practical applications, such as finding the quickest route from location A to location B.
% Introduce the problem of msp
While the \emph{shortest-path problem} minimizes for a single criteria, e.g., the travel time, in practical applications one often wants to optimize multiple -- and possibly conflicting -- objectives:
When searching for a route from A to B, we may want to minimize the travel time as well as toll costs.
In such a setting, we usually cannot give a single best solution anymore. 
Instead, we can give several reasonable solutions: 
The fastest route will usually use highways, thus increasing the toll costs, while a slightly slower route may reduce the toll costs by avoiding highways. 
Problems like this can be modeled as \emph{multi-criteria shortest path} (MSP) problems, where we are interested in all optimal alternatives, i.e., in routes that are \emph{Pareto-optimal}. 
A route from A to B is Pareto-optimal if there is no other route with less or equal cost for each of the $d$ objectives.

%subsection{Definitions and notation} \label{sec:shortest_path:defs}
In the following, we provide definitions for variations of the shortest path problems considered in this report. 
The classic text book by Cormen et al.~\cite{CLRS01} provides a more detailed introduction to basic shortest path problems and algorithms.

% Define single-source shortest path
\subsection{The classical shortest path problem} \label{sec:shortest_path:defs:sssp}
We are given a weighted directed graph $G=(V,A)$, where $V= \{v_1, v_2, \dots, v_n\}$ is a finite set of nodes, $A \subseteq V \times V$ is a finite set of arcs (directed edges) and $c: A \rightarrow \mathbb{N}$ is the cost or weight function. 
We define the set of neighbors of a node $v$ as the nodes adjacent to an outgoing arc of $v$, i.e., $\{w \in V \mid \exists a\in A, a = (v,w) \}$.
W.l.o.g., we assume that $G$ is a connected graph.

Let $p = \langle v_0, a_1, v_1, a_2, \dots,a_k, v_k \rangle$ be a path\footnote{We will also write $p = \langle v_0, v_1, \dots,v_k \rangle$ when not dealing with multigraphs, since an arc $a_i$ is well defined by its two adjacent nodes.}from $v_0$ to $v_k$ in $G$.
Furthermore, let $P$ be the set of all paths and $P_{u,v}$ be the set of all paths from node $u$ to node $v$ in $G$.
We define the weight $w(p)$ of a path $p$ as 
\begin{align*}
w: P &\rightarrow \mathbb{N} \\
p &\mapsto w(p) = \sum_{i=1}^{k}c(a_i) \quad , \neqn{sssp_weighted}
\end{align*}
i.e., the sum of costs all the arcs in the path $p$.

% Variations: Single source, all-pairs,... shortest path
In a \emph{single-source shortest path problem (SSSP)}, we want to compute a shortest path w.r.t.~some weight function $w$ from a given source node $s \in V$ to each node $v \in V$.
Different variations of the problem exist, such as the \emph{single-destination}, the \emph{single-pair} or the \emph{all-pairs} shortest path problem. 
Note that an optimal algorithm for the SSSP can easily be turned into an optimal algorithm for the first two variants \cite{CLRS01}.
Thus, we will only deal with the SSSP in this report.

\subsection{Multi-criteria shortest path (MSP)} \label{sec:shortest_path:defs:msp}
%MSP
Multi-criteria shortest path problems \cite{Martins84} generalize shortest path problems w.r.t.~the weight function $c$, which is extended to $d$-dimensional vectors, i.e., $\vect{c}: A \rightarrow \mathbb{N}^d$ and
\begin{align*}
\vect{w}: P &\rightarrow \mathbb{N}^d \\
p &\mapsto \vect{w}(p) = (w_1(p), w_2(p), \dots , w_d(p)) \quad , \neqn{msp_weighted}
\end{align*}
where $w_j(p) = \sum_{i=1}^{k}c_j(a_i)$ $\forall j \in \{1,\dots,d\}$.

%Domination relation
Let $\vect{x}$ and $\vect{y}$ be two vectors of dimension $d$, i.e., $\vect{x}, \vect{y} \in \mathbb{N}^d$ and $\vect{x} \neq \vect{y}$. 
We say that $\vect{x}$ \emph{dominates} $\vect{y}$ ($\vect{x} \prec \vect{y}$) -- or equivalently, $\vect{y}$ \emph{is dominated by} $\vect{x}$ -- if and only if
\begin{align}
\forall j \in \{1,\dots, d\}: w_j(x) \leq w_j(y) \quad .
\end{align}
Note that the dominance relation ($\prec$) does not define a total ordering in $\mathbb{R}^d$ for $d\geq 2$.
Thus, there exist vectors $\vect{x}, \vect{y} \in \mathbb{N}^d$, $\vect{x} \neq \vect{y}$ for which neither $\vect{x} \prec \vect{y}$ nor $\vect{y} \prec \vect{x}$ holds.

% Notes
A path $p$ from node $v_1$ to node $v_2$ is a \emph{Pareto-optimal} or \emph{non-dominated} path if there is no path $q \in P$ from $v_1$ to $v_2$ s.t.~$q \prec p$.
Informally, we also call a Pareto-optimal path $p$ \emph{shortest path}.
Thus, for the MSP, the solution consists of a set of Pareto-optimal paths for each considered pair of nodes.


\subsubsection*{Applications} \label{sec:shortest_path:applications} 
% Applications
Apart from the problem of finding an optimal route in a road map as outlined above, the MSP problem has numerous outer applications, such as routing in multimedia networks \cite{ClimacoCP03}, route guidance \cite{JahnMS00} and curve approximation \cite{MehlhornZ00}.

\subsubsection*{Hardness and practicality} \label{sec:shortest_path:hardness}
% Hardness of the problem, reason for parallelization
% Note that the graph instances resulting from modeling practical problems are potentially very large. 
The crucial parameter for the complexity of the MSP is the total number of Pareto optima for all visited nodes. 
Since this number is exponential in $n$ in the worst case \cite{Hansen80}, the MSP is in general NP-hard.
Even for $d=2$, the decision problem whether there exists a path between two nodes whose length is below a given threshold is NP-hard \cite{GareyJ79}.
However, it was observed that the problem is efficiently tractable from a practical viewpoint for many practically relevant instances. 
The input data of practical applications tends to have certain characteristics, which lead to the set of Pareto optima for a vertex to be polynomially bounded \cite{Muller-HannemannW06}. 
It was shown that in applied scenarios this number may even be bounded by a small constant \cite{Muller-HannemannW01}. 
Thus, MSP can be solved efficiently for small $d$ and not too large graphs adhering certain characteristics.

% reason for parallelization
However, due to the potentially very large graph instances resulting from modeling e.g., road or railway networks, the computational cost is significant even if a small number of criteria is to be optimized.
Guerriero and Musmanno \cite{GuerrieroM01} thus suggest that parallel computing might help to design efficient solution methods. 

\subsubsection*{Approximate solutions} \label{sec:shortest_path:approx}
% heuristics
Due to the hardness of the MSP, heuristic methods are sometimes employed (see, e.g., \cite{BastMS03, Sonnier06, EhrgottG02}).
% weighted sum approach
A common approach is to define a total order relation $\tor$ on $P$ that allows for a more efficient computation of the Pareto-optima.
Such a relation $\tor$ has to satisfy the following properties\footnote{We denote the concatenation of two paths $p_1 \in P_{u,v}$, $p_2 \in P_{v,w}$ as $\cP{p_1}{p_2}$}
\begin{align}
\forall p,q \in P_{u,v}: p \prec q \implies p \tor q  \quad \text{Dominance} \\
\forall p \in P_{u,v}, \forall (v,w) \in A: p \tor \cP{p}{w} \quad \text{Monotonic}
\end{align}
Martins et al.~\cite{MartinsPRS07} show that the following relation satisfies these requirements:
\begin{align}
p \osum q \iff \sum_{i=1}^{d} w_i(p) \leq  \sum_{i=1}^{d} w_i(q) 
\end{align}
% supported/non-supported solutions
However, as Sonnier \cite{Sonnier06} points out, a problem with algorithms based on such a relation is that 
\begin{align}
p \osum q  \notimplies p \prec q \quad , \neqn{osum_problem}
\end{align}
i.e., only solutions that lie on the convex hull of the feasible region are found, which are called the supported solutions. 
In other words, there exist Pareto-optima which may not be found because of the property given in Eq.~\ref{eq:osum_problem}.

% graph example from Sonnier
To see this, consider the following example from Sonnier \cite{Sonnier06}.
Assume we are interested in the Pareto-optimal paths from node 1 to node 5 in the graph depicted in Fig.~\ref{fig:example_graph}.

\begin{figure}
\begin {center}
\begin {tikzpicture}[-latex, auto, node distance = 3 cm, on grid, semithick, state/.style = {circle, top color = white, draw, minimum width = 1 cm}]
\node[state] (n1) {$1$};
\node[state] (n2) [below right of = n1] {$2$};
\node[state] (n3) [above right of = n2] {$3$};
\node[state] (n4) [below right of = n3] {$4$};
\node[state] (n5) [above right of = n4] {$5$};
\path (n1) edge node[above = 0.05 cm] {$(1,4)$} (n3);
\path (n3) edge node[above = 0.05 cm] {$(4,1)$} (n5);
\path (n1) edge [bend right = 30] node[below = 0.2 cm] {$(1,1)$} (n2);
\path (n2) edge [bend right = 30] node[below = 0.2 cm] {$(1,2)$} (n3);
\path (n3) edge [bend right = 30] node[below = 0.2 cm] {$(2,1)$} (n4);
\path (n4) edge [bend right = 30] node[below = 0.2 cm] {$(1,1)$} (n5);
%\path (n1) edge [bend left = 30, color=red] node[above = 0.2 cm, color=red] {$(3.8,6.8)$} (n5);
\end{tikzpicture}
\end{center}
\caption{A weighted ($d=2$) directed graph.}
\label{fig:example_graph}
\end{figure}

The solution set is shown in Table \ref{table:pareto_paths}; note that all the paths are supported solutions, since we have 
\begin{align}
\forall j,k \in \{1,\dots,4\}: \sum_{i=1}^{d} w_i(p_j) =  \sum_{i=1}^{d} w_i(p_k) \quad .
\end{align}

\begin{table*}
\begin{center}
    \begin{tabular}{| l | c |}
    \hline
    \textbf{Path} & \textbf{Weight vector} \\ \hline \hline
    $p_1 = \langle 1,2,3,4,5 \rangle$ & (5,5) \\ \hline
    $p_2 = \langle 1,3,4,5\rangle$  & (4,6) \\ \hline
    $p_3 = \langle 1,2,3,5\rangle$  & (3,7) \\ \hline
    $p_4 = \langle 1,3,5\rangle$ & (2,8) \\ \hline
    %$p_5$: 1-5 & (3.8,6.8) \\ \hline
    \end{tabular}
    \caption{Pareto-optimal paths from node 1 to node 2 in the graph of Fig.~\ref{fig:example_graph}}
    \label{table:pareto_paths}
\end{center}
\end{table*}

We extend the example by adding an arc $(1,5)$ with weight vector $(3.8,6.8)$.
Note that now, in addition to the previous solutions, the path $p_5 = \langle 1,5 \rangle $ is a Pareto-optimal path.
However, we have 
\begin{align}
\forall j \in \{1,\dots,4\}: \sum_{i=1}^{d} w_i(p_j) < \sum_{i=1}^{d} w_i(p_5) \quad ,
\end{align}
i.e., $p_5$ is not on the convex hull an thus called an \emph{unsupported non-dominated solution}, as depicted in Fig. \ref{fig:unsupported_solution}.
% approximate solution set
Thus, an \emph{approximate solution set} provides a ``reasonable'' set of non-dominated paths, but is not necessarily complete.

\begin{figure}
\begin{center}
\begin{tikzpicture}
\begin{axis}[xlabel=$w_1$, ylabel=$w_2$, nodes near coords, enlargelimits=0.2]
	\addplot+[color=blue, mark=*, point meta=explicit symbolic] 
	coordinates {
		(5,5) [$p_1$]
		(4,6) [$p_2$]
		(3,7) [$p_3$]
		(2,8) [$p_4$]
	};
	\addplot+[color=red, mark=*, point meta=explicit symbolic] 
	coordinates {
		(3.8,6.8) [$p_5$]
	};
\end{axis}
\end{tikzpicture}
\end{center}
\caption{An unsupported non-dominated solution: $p_5$}
\label{fig:unsupported_solution}
\end{figure}

\subsubsection*{Mutligraphs} \label{sec:shortest_path:defs:multigraph}
A multigraph is a graph that may contain parallel edges, that is, multiple edges may connect the same two nodes. 
Formally, a directed multigraph $G=(V,A)$ consists of a finite set of nodes $V = \{v_1, v_2,\dots,v_n \}$ and a finite multiset\footnote{In contrast to a set, a multiset may contain the same element multiple times.} of arcs and a function $f$, 
\begin{align}
f: A &\rightarrow (u,v) \text{ where } u,v \in V \quad .
\end{align}

The definition of weighted multigraphs is analogous to the definition of weighted graphs given in Eq.~\ref{eq:msp_weighted}. 

% our algorithm works on multigraphs too!
\todo{This should go somewhere else - it certainly does not belong to the formal definitions}
We note that in contrast to the algorithms mentioned in Section \ref{sec:related}, our algorithm works on multigraphs as well and provide a comparative performance evaluation in Section \todo{well, where?}.



\section{Multi-criteria shortest path algorithm} \label{sec:msp_algo}
% what we do in this section
In this section, we present our algorithm for the MSP.
% Problem setting
We want to compute an exact solution of the MSP for directed graphs with multi-dimensional weight vectors (as defined in Section \ref{sec:shortest_path:defs:msp}). 
% Intro to the algorithm: generalization of Dijkstra
The algorithm follows the principles of Dijkstra's algorithm (we generate a set of candidates and expand the most promising first), where the problem of finding intermediate paths that are Pareto-optimal is delegated to a priority queue. 
Our algorithm relies on the Pheet task scheduling framework for parallelization and, in particular, on Pheet's concept of \emph{priority task scheduling} (Section \ref{sec:pheet:priority_sched}), which allows to combine the work pool of the scheduler with the priority queue used by the algorithm into one data structure: a priority-aware task scheduler.

% Works with different schedulers/task storages
We designed the algorithm s.t.~it may easily employ different task scheduler implementations without any major changes to the algorithm itself. 
Within this framework, we only have to provide implementations of 
\begin{inparaenum}[(i)]
\item the task and 
\item a scheduling strategy.
\end{inparaenum}

% The algorithm is label-correcting (no strict sequence; furthermore, we have a set of solutions for each node)

% Explain graph class?



% Abstract description of the algorithm
\begin{algorithm}
\caption{Pseudo-code for our MSP algorithm}
\label{algo:abstractMSP}
\begin{algorithmic}[1]
\Require{Graph $G$, start node $s$}
\ForAll{$v \in G$}
  \State $S_p[v] \gets \{\}$ \Comment{Initialize the Pareto-set for each node}
\EndFor
\State $S_p[s] \gets \{ \vect{0} \} $ \Comment{Shortest path from $s$ to $s$ is the null-vector}
\State $U \gets \{\langle s \rangle\}$ \Comment{Set of paths that need to be explored further}
\While{$U$ is not empty}
  \State Take path $p$ from $U$ 
  \State \Call{expand}{$p$}
\EndWhile
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Pseudo-code for expanding a candidate path}
\label{algo:abstractExpand}
\begin{algorithmic}[1]
\Require{$S_p[v]$: Set of Pareto-optimal paths to node $v$ ($\forall v\in V$)}
\Require{$U$: Set of paths that need to be explored further}
\Require{$p=\langle s, \dots, v \rangle$ is a path in Graph $G$ from start node $s$ to $v$}
\Function{expand}{Path $p$}
\ForAll{$w \in p$.head.neighbors} 
  \State $p' \gets \cP{p}{w}$	\Comment{Generate candidate}
  \If{$\nexists x \in S_p[w] \text{ s.t.\ } x \prec p'$} 
  \Statex \Comment{Candidate is not dominated by any path in the Pareto-set}
    \ForAll{$y\in S_p[w]$} \Comment{Remove any path dominated by $p'$}
      \If{$p' \prec y$}
	\State $S_p[w] \gets S_p[w] \setminus y$
      \EndIf
    \EndFor
    \State $S_p[w] \gets S_p[w] \cup p'$ \Comment{Add $p'$ to the Pareto-set for node $w$}
    \State $U \gets U \cup p'$ \Comment{$p'$ needs to be explored further}
  \EndIf
\EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

% Explain the pareto set
\begin{minipage}[c]{\linewidth}
\begin{lstlisting}[label=lst:ParetoSet, caption=Pareto set operations.]
class ParetoSet {
  /* Insert p into the Pareto-set. Any path p' that is dominated by p will be marked dominated and removed from the set. If p is dominated by a path p' already in the set, p will be marked domianted and will not be inserted into the set. */
  bool insert(Path p);

  /* Get all the paths stored in this Pareto-set. */
  Set<Path> paths();
}
\end{lstlisting}
\end{minipage}

% Msp task
\begin{minipage}[c]{\linewidth}
\begin{lstlisting}[label=lst:MspTask, caption=MSP Task.]
class Task {
public:
  Task(Path p, ParetoSets Sp) //Constructor. Save parameters.
      : p(p), Sp(Sp) { }
  
  void execute() {
    /* The path this task was spawned for might be obsolete. */
    if(p.dominated) return;	
    Set<Path> candidates;
    /* Generate new candidates */
    for (Arc a : p.head().outgoing_edges()) {
      Path q = p.step(e);
      candidates.insert(q);
    }
    /* Add the candidates to the global pareto sets */
    Set<Path> added;
    added = Sp.insert(candidates);
    for (Path p : added) {
      if(!p.dominated()) {
	/* Spawn a new task for each added path */
	spawn_task(p, Sp);
      }
    }
  }
private:
  Path p;
  ParetoSets Sp;
}
\end{lstlisting}
\end{minipage}

\begin{comment}
% Msp task
\begin{algorithm}
\caption{MSP Task}
\label{algo:msptask}
\begin{algorithmic}[1]
   \Function{initialize}{Graph $g$, Path $p$, Pareto\_Sets $s$} 
      \State $\sC \gets \{\}$ \Comment{Set of candidates a task generates}
      \State $\dots$  \Comment{Store $g$, $p$ and $s$ for this instance of Task}
   \EndFunction
  \Statex
  \Function{execute}{}
    \If{$p$ is dominated} 
      \State return	\Comment{This task instance is obsolete}
    \EndIf
    \State Node $h \gets p$.head	\Comment{The last node of path $p$}
    \ForAll{$v \in h$.neighbors} \Comment{All neighbors of $h$}
      \State $\sC = \sC \cup \cP{p}{v}$ \Comment{Generate candidates}
    \EndFor
    \State $\sA \gets s$.insert(\sC) \Comment{Inserts the generated candidates into global Pareto set}
    \Statex \Comment{$\sA$ contains candidates not dominated by any path in $s$}
    \ForAll{$p\in \sA$}
      spawn\_task($g$, $p$, $s$) \Comment{Spawn a new task for each candidate}
    \EndFor
  \EndFunction
\end{algorithmic}
\end{algorithm}
\end{comment}

The following implementation variants are provided:
\begin{itemize}
% \item \verb|SequentialMsp|:
% \item \verb|StrategyMsp|:
\item \verb|Strategy2MspLSM|: \todo{we need to introduce the lsm somewhere}
% \item \verb|Strategy2MspKLSM|:
\item \verb|Strategy2MspPareto|:
\end{itemize}

% sequential algorithm: uses a priority queue

% StrategyScheduler: 

% Strategy2Scheduler, variants:



\section{Performance evaluation} \label{sec:eval}

% Mars hardware
For performance evaluation, we used a shared memory system nicknamed \emph{Mars}, an Intel Xeon based system with the properties listed in Table \ref{table:mars}.
\begin{table*}
\begin{center}
    \begin{tabular}{| l | l |}
    \hline
    CPU model & Intel Xeon E7-8850 \\ \hline
    Number of cores & 80 (8 nodes with 10 cores each) \\ \hline
    CPU clock & 2.00 GHz \\ \hline
    L1i & 32 KB \\ \hline
    L1d & 32 KB \\ \hline
    L2 & 256 KB \\ \hline
    L3 & 24576 KB \\ \hline
    Main memory & 1 TB \\ \hline    
    \end{tabular}
    \caption{Hardware configuration of Mars}
    \label{table:mars}
\end{center}
\end{table*}
% compiler 
For all experiments, Pheet was compiled using \verb|clang 3.4.2-7| with the the \verb|-O3| flag to allow standard compiler optimizations.

\subsection{Test instances} \label{sec:eval:test_instances}
% test graphs
All input instances were created by \verb|PHEET_HOME/test/msp/lib/Graph/Generator/main.h|, which generates a random connected digraph with the following arguments:
\begin{compactitem}
\item \verb|n|: Number of nodes.
\item \verb|m|: Number of edges.
\item \verb|d|: Degree of the weight vectors.
\item \verb|w|: Upper limit for all dimensions of the weight vectors.
\item \verb|r|: Random seed value.
\end{compactitem}
If the option \verb|-p| is given, a multigraph will be generated. 
Otherwise, the generated graph will contain no parallel edges.
\subsection{Methodology} \label{sec:eval:methodology}
% number of runs
% confidence intervals



\section{Related work} \label{sec:related}
%--------------------------------------------------------------------------------------------
%Should related work be covered near the beginning of the paper or near the end?
%   - Beginning, if it can be short yet detailed enough, or if it's critical to take a strong defensive stance about previous work right away. In this case Related Work can be either a subsection at the end of the Introduction, or its own Section 2.
%   	- End, if it can be summarized quickly early on (in the Introduction or Preliminaries), or if sufficient comparisons require the technical content of the paper. In this case Related Work should appear just before the Conclusions, possibly in a more general section "Discussion and Related Work".
%--------------------------------------------------------------------------------------------

% Ehrgott, Gandibleux: 
For an overview of related work for the MCSP without parallelization, we refer to the annotated bibliography of multiobjective combinatorial optimization \cite{EhrgottG02}, specifically Section ``6.1 Shortest path problems''.

% Bi-criteria

% Sonnier: approximate solutions for d \in {3,4}
Sonnier \cite{Sonnier06} were one of the first to publish parallel algorithms for solving MSP problems with 3 or 4 objectives. 
Their algorithms are based on a weighted sum approach and thus provide only an approximate solution, i.e., the solution set may not contain all Pareto-optimal paths.

% Sanders, Erb: first parallel MSP algo, but mostly for d=2
To the best of our knowledge, Sanders and Mandow \cite{SM13} published the first proposal for a parallel algorithm that provides an exact solution of the MSP.
Their approach extends Dijkstra's classical algorithm \cite{Dijkstra59} and relies on a so called \emph{Pareto queue}, a multi-dimensional generalization of a priority queue. 
While they give a high level description of the algorithm for arbitrary $d \geq 2$ and a detailed description of the bi-criteria case (which was further engineered by Erb \cite{Erb13}), they also state that efficient priority queues for $d\geq3$ are not yet known.

\section{Conclusion} \label{sec:conclusion}
\todo{...}
\section{Acknowledgements} \label{sec:ack}
\todo{...}


%bibliography
\bibliographystyle{acm}
\bibliography{sources} 



%tmp plots
\section{Plots}
\subsection{28.08.}

\begin{figure}[H]
\begin{center}
<<fig=TRUE, echo=FALSE>>=
plotOverCpus(
"../benchmarks/local/g_2000_13000_3_10000_42/08_28/base/s2pareto.dat",
"../benchmarks/local/g_2000_13000_3_10000_42/08_28/1/s2pareto.dat",
"../benchmarks/local/g_2000_13000_3_10000_42/08_28/2/s2pareto.dat",
"../benchmarks/local/g_2000_13000_3_10000_42/08_28/3/s2pareto.dat",
"../benchmarks/local/g_2000_13000_3_10000_42/08_28/4/s2pareto.dat",
yAxis="total_time", from=1, to=80)
@
\end{center}
\caption{Improvements on 28-08}
\end{figure}

\begin{figure}[H]
\begin{center}
<<fig=TRUE, echo=FALSE>>=
plotOverCpus(
"../benchmarks/local/g_2000_13000_3_10000_42/08_28/s2pareto.dat",
"../benchmarks/local/g_2000_13000_3_10000_42/08_28/strategy.dat",
"../benchmarks/local/g_2000_13000_3_10000_42/08_28/s2lsm.dat",
"../benchmarks/local/g_2000_13000_3_10000_42/08_28/s2klsm.dat",
yAxis="total_time", from=1, to=80)
@
\end{center}
\caption{s2pareto vs.\ s2lsm vs.\ s2klsm vs.\ strategy}
\end{figure}

\begin{figure}[H]
\begin{center}
<<fig=TRUE, echo=FALSE>>=
plotOverCpus(
"../benchmarks/local/g_2000_13000_3_10000_42/08_28/s2pareto.dat",
"../benchmarks/local/g_2000_13000_3_10000_42/08_28/strategy.dat",
"../benchmarks/local/g_2000_13000_3_10000_42/08_28/s2lsm.dat",
"../benchmarks/local/g_2000_13000_3_10000_42/08_28/KDSet/s2pareto.dat",
"../benchmarks/local/g_2000_13000_3_10000_42/08_28/KDSet/strategy.dat",
"../benchmarks/local/g_2000_13000_3_10000_42/08_28/KDSet/s2lsm.dat",
yAxis="total_time", from=1, to=80)
@
\end{center}
\caption{Each strategy/task storage with NaiveSet and KDSet}
\end{figure}

\begin{figure}[H]
\begin{center}
<<fig=TRUE, echo=FALSE>>=
plotOverCpus(
"../benchmarks/local/g_2000_13000_3_10000_42/08_28/s2pareto.dat",
"../benchmarks/local/g_2000_13000_3_10000_42/08_28/lincomb/s2pareto.dat",
yAxis="total_time", from=1, to=80)
@
\end{center}
\caption{s2pareto with lincomb and pareto strategy}
\end{figure}


\subsection{29.08.}
\begin{figure}[H]
\begin{center}
<<fig=TRUE, echo=FALSE>>=
plotOverCpus(
"../benchmarks/local/g_2000_13000_3_10000_42/08_28/s2pareto.dat",
"../benchmarks/local/g_2000_13000_3_10000_42/08_29/1/s2pareto.dat",
yAxis="total_time", from=1, to=80)
@
\end{center}
\caption{Set path dominated in NaiveSet if necessary}
\end{figure}

\begin{figure}[H]
\begin{center}
<<fig=TRUE, echo=FALSE>>=
plotOverCpus(
"../benchmarks/mars/g_2000_13000_3_10000_42/08_29/s2pareto.dat",
"../benchmarks/mars/g_2000_13000_3_10000_42/08_29/s2lsm.dat",
"../benchmarks/mars/g_2000_13000_3_10000_42/08_29/s2klsm.dat",
"../benchmarks/mars/g_2000_13000_3_10000_42/08_29/strategy.dat",
yAxis="total_time", from=1, to=80)
@
\end{center}
\caption{Different strategyies/task storages on mars}
\end{figure}

\end{document}
