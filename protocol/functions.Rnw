#lookup table for human readable description of column names
desc <- c(
test="test",
algorithm="algorithm",
scheduler="scheduler",
nodes="#nodes",
edges="#edges",
paths="#paths",
cpus="#cpus",
total_time="time [s]",
num_dead_tasks="#dead tasks",
num_actual_tasks="#created tasks",
comment="comment"
)

# create a nice plot
plot <- function(x, y, pch, legend, xlab, ylab, legendPos, log) {
    matplot(x,y, pch=pch, type='b', xlab=xlab, ylab=ylab, log=log)
    legend(legendPos, legend=legend, col=pch, pch=pch)
}

#read benchmark data from files
readDataFrom <- function(...) {
	files <- c(...)
	d <- NULL
	
	for (f in files) {
		tmp <- read.table(f, header=TRUE, sep=",")
		d <- rbind(d, tmp)
	}
	d
}

# generic function to plot benchmark data
plotBenchmark <- function(..., xAxis, yAxis, splitBy, legendPos="topright", log="", aggFun=min) {
   d <- readDataFrom(...)
    # take the minimum of all runs
    ad <- aggregate(d[[yAxis]], 
   					list(
                        test = d$test,
                        algorithm = d$algorithm, 
                        scheduler = d$scheduler, 
                        comment = d$comment,
                        xAxis = d[[xAxis]]),
   					aggFun)		
   	# split 				
    sd <- split(ad, ad[[splitBy]])
   
    # Add each data range to our vectors.
    # The <<- operator affects variables in higher scopes.
    addData <- function(p) {
    	p <- p[with(p, order(p$xAxis)),]
        if (nrow(p) > 0) {
            x <<- cbind(x,p$xAxis)
            y <<- cbind(y,p$x)
        }
    }
    
    x <- NULL
    y <- NULL
    sapply(sd, FUN=addData)
	pch <- 1:length(sd)
        
    plot(x, y, pch, levels(ad[[splitBy]]), desc[xAxis], desc[yAxis], legendPos, log)   
}

plotOverCpus <- function(..., yAxis, splitBy, legendPos="topright", log="", from=1, to=80, aggFun=min) {
    d <- readDataFrom(...)
    xAxis="cpus"
    
    # take the minimum of all runs
    ad <- aggregate(d[[yAxis]], 
                    list(
                        test = d$test, 
                        algorithm = d$algorithm, 
                        scheduler = d$scheduler, 
                        comment = d$comment, 
                        xAxis = d[[xAxis]]), 
                    aggFun)       
    
    # only use data sets where #cpus >= from and <= to
    fd <- subset(ad, ad$xAxis >= from & ad$xAxis <= to)
    
    # split                 
    sd <- split(fd, fd[[splitBy]])
   
    # Add each data range to our vectors.
    # The <<- operator affects variables in higher scopes.
    addData <- function(p) {
        p <- p[with(p, order(p$xAxis)),]
        if (nrow(p) > 0) {
            x <<- cbind(x,p$xAxis)
            y <<- cbind(y,p$x)
        }
    }
    
    x <- NULL
    y <- NULL
    sapply(sd, FUN=addData)
    pch <- 1:length(sd)
        
    plot(x, y, pch, levels(ad[[splitBy]]), desc[xAxis], desc[yAxis], legendPos, log)   
}

plotPerformanceVariance <- function(file, from=1, to=80) {
    d <- readDataFrom(file)
    # only use data sets where #cpus >= from and <= to
    fd <- subset(d, d$cpus >= from & d$cpus <= to)
    
    # we only need two columns of the data
    ad <- cbind(fd$cpus, fd$total_time)
    
    sd <- split(ad[,2], ad[,1])
    
    boxplot(sd)
}